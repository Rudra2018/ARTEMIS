"""
Vulnerability Assessment Agent - Specialized AI Agent for Vulnerability Analysis
==============================================================================

This agent focuses on comprehensive vulnerability assessment, classification,
and risk analysis with machine learning-enhanced detection capabilities.
"""

import asyncio
import json
import logging
import time
from datetime import datetime
from typing import Dict, List, Any, Optional
import aiohttp
from urllib.parse import urlparse

from ..agent_orchestrator import BaseAgent, AgentTask, AgentResult

logger = logging.getLogger(__name__)

class VulnerabilityAgent(BaseAgent):
    """Specialized agent for vulnerability assessment and analysis"""

    def __init__(self, agent_id: str = "vulnerability_agent", config: Dict[str, Any] = None):
        super().__init__(agent_id, config)

        # Vulnerability databases and patterns
        self.vulnerability_patterns = self._initialize_vulnerability_patterns()
        self.owasp_categories = self._initialize_owasp_categories()
        self.cve_patterns = self._initialize_cve_patterns()

        # Risk assessment matrices
        self.risk_matrix = self._initialize_risk_matrix()
        self.severity_scoring = self._initialize_severity_scoring()

        # Learning components
        self.pattern_effectiveness = {}
        self.false_positive_tracking = {}
        self.vulnerability_trends = {}

    def get_capabilities(self) -> List[str]:
        """Return capabilities of this agent"""
        return [
            'vulnerability_agent',
            'vulnerability_assessment',
            'risk_analysis',
            'owasp_classification',
            'cve_analysis',
            'exploit_detection',
            'severity_scoring',
            'false_positive_filtering'
        ]

    async def execute_task(self, task: AgentTask) -> AgentResult:
        """Execute vulnerability assessment task"""
        start_time = time.time()

        try:
            logger.info(f"Vulnerability Agent executing task: {task.task_id}")

            # Parse task parameters
            scan_type = task.parameters.get('scan_type', 'comprehensive')
            focus_areas = task.parameters.get('focus_areas', [])
            risk_threshold = task.parameters.get('risk_threshold', 'medium')

            findings = []
            vulnerability_results = {
                'vulnerability_summary': {},
                'detailed_findings': [],
                'risk_assessment': {},
                'owasp_mapping': {},
                'exploit_analysis': {},
                'remediation_guidance': {},
                'assessment_methods': []
            }

            # Web application vulnerabilities
            webapp_vulns = await self._assess_webapp_vulnerabilities(task.target, task.parameters)
            vulnerability_results['detailed_findings'].extend(webapp_vulns['findings'])
            findings.extend(webapp_vulns['findings'])
            vulnerability_results['assessment_methods'].extend(webapp_vulns.get('methods', []))

            # Infrastructure vulnerabilities
            infra_vulns = await self._assess_infrastructure_vulnerabilities(task.target, task.parameters)
            vulnerability_results['detailed_findings'].extend(infra_vulns['findings'])
            findings.extend(infra_vulns['findings'])
            vulnerability_results['assessment_methods'].extend(infra_vulns.get('methods', []))

            # API security vulnerabilities
            api_vulns = await self._assess_api_vulnerabilities(task.target, task.parameters)
            vulnerability_results['detailed_findings'].extend(api_vulns['findings'])
            findings.extend(api_vulns['findings'])
            vulnerability_results['assessment_methods'].extend(api_vulns.get('methods', []))

            # Configuration vulnerabilities
            config_vulns = await self._assess_configuration_vulnerabilities(task.target, task.parameters)
            vulnerability_results['detailed_findings'].extend(config_vulns['findings'])
            findings.extend(config_vulns['findings'])
            vulnerability_results['assessment_methods'].extend(config_vulns.get('methods', []))

            # Risk assessment and classification
            risk_assessment = await self._perform_risk_assessment(findings)
            vulnerability_results['risk_assessment'] = risk_assessment

            # OWASP mapping
            owasp_mapping = await self._map_to_owasp_categories(findings)
            vulnerability_results['owasp_mapping'] = owasp_mapping

            # Exploit analysis
            exploit_analysis = await self._analyze_exploitability(findings)
            vulnerability_results['exploit_analysis'] = exploit_analysis

            # Generate remediation guidance
            remediation = await self._generate_remediation_guidance(findings)
            vulnerability_results['remediation_guidance'] = remediation

            # Create vulnerability summary
            vulnerability_results['vulnerability_summary'] = self._create_vulnerability_summary(findings)

            # Calculate confidence score
            confidence_score = self._calculate_confidence_score(vulnerability_results, findings)

            # Update learning data
            self._update_learning_data(vulnerability_results, findings)

            execution_time = time.time() - start_time

            return AgentResult(
                task_id=task.task_id,
                agent_type=self.agent_id,
                success=True,
                data=vulnerability_results,
                execution_time=execution_time,
                confidence_score=confidence_score,
                findings=findings,
                metadata={
                    'scan_type': scan_type,
                    'total_vulnerabilities': len(findings),
                    'critical_count': len([f for f in findings if f.get('severity') == 'critical']),
                    'high_count': len([f for f in findings if f.get('severity') == 'high']),
                    'medium_count': len([f for f in findings if f.get('severity') == 'medium']),
                    'low_count': len([f for f in findings if f.get('severity') == 'low'])
                }
            )

        except Exception as e:
            execution_time = time.time() - start_time
            logger.error(f"Vulnerability Agent task failed: {e}")

            return AgentResult(
                task_id=task.task_id,
                agent_type=self.agent_id,
                success=False,
                data={'error': str(e)},
                execution_time=execution_time,
                confidence_score=0.0,
                findings=[],
                metadata={'error': str(e)}
            )

    async def _assess_webapp_vulnerabilities(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Assess web application vulnerabilities"""
        findings = []
        methods_used = ['webapp_vulnerability_assessment']

        # SQL Injection tests
        sqli_findings = await self._test_sql_injection(target)
        findings.extend(sqli_findings)

        # XSS tests
        xss_findings = await self._test_xss_vulnerabilities(target)
        findings.extend(xss_findings)

        # CSRF tests
        csrf_findings = await self._test_csrf_vulnerabilities(target)
        findings.extend(csrf_findings)

        # Directory traversal tests
        traversal_findings = await self._test_directory_traversal(target)
        findings.extend(traversal_findings)

        # Authentication bypass tests
        auth_findings = await self._test_authentication_bypass(target)
        findings.extend(auth_findings)

        return {
            'findings': findings,
            'methods': methods_used
        }

    async def _assess_infrastructure_vulnerabilities(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Assess infrastructure vulnerabilities"""
        findings = []
        methods_used = ['infrastructure_vulnerability_assessment']

        # SSL/TLS vulnerabilities
        ssl_findings = await self._test_ssl_vulnerabilities(target)
        findings.extend(ssl_findings)

        # HTTP security headers
        header_findings = await self._test_security_headers(target)
        findings.extend(header_findings)

        # Server information disclosure
        disclosure_findings = await self._test_information_disclosure(target)
        findings.extend(disclosure_findings)

        return {
            'findings': findings,
            'methods': methods_used
        }

    async def _assess_api_vulnerabilities(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Assess API-specific vulnerabilities"""
        findings = []
        methods_used = ['api_vulnerability_assessment']

        # API enumeration
        enum_findings = await self._test_api_enumeration(target)
        findings.extend(enum_findings)

        # Rate limiting
        rate_findings = await self._test_rate_limiting(target)
        findings.extend(rate_findings)

        # Authentication issues
        api_auth_findings = await self._test_api_authentication(target)
        findings.extend(api_auth_findings)

        return {
            'findings': findings,
            'methods': methods_used
        }

    async def _assess_configuration_vulnerabilities(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Assess configuration vulnerabilities"""
        findings = []
        methods_used = ['configuration_vulnerability_assessment']

        # Default credentials
        default_findings = await self._test_default_credentials(target)
        findings.extend(default_findings)

        # Backup files
        backup_findings = await self._test_backup_files(target)
        findings.extend(backup_findings)

        # Configuration files
        config_findings = await self._test_configuration_files(target)
        findings.extend(config_findings)

        return {
            'findings': findings,
            'methods': methods_used
        }

    async def _test_sql_injection(self, target: str) -> List[Dict[str, Any]]:
        """Test for SQL injection vulnerabilities"""
        findings = []

        # SQL injection payloads
        payloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "' AND SLEEP(5)--",
            "admin'--"
        ]

        for payload in payloads:
            try:
                test_data = {
                    "jsonrpc": "2.0",
                    "method": "chat",
                    "params": {"message": payload},
                    "id": "sqli_test"
                }

                async with aiohttp.ClientSession() as session:
                    async with session.post(target, json=test_data, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        response_text = await response.text()

                        # Check for SQL error messages
                        error_patterns = [
                            'sql syntax error',
                            'mysql_fetch',
                            'ora-01756',
                            'microsoft ole db',
                            'postgresql error'
                        ]

                        if any(pattern in response_text.lower() for pattern in error_patterns):
                            findings.append({
                                'type': 'sql_injection',
                                'severity': 'high',
                                'description': 'Potential SQL injection vulnerability detected',
                                'payload': payload,
                                'response_excerpt': response_text[:200],
                                'owasp_category': 'A03:2021 - Injection',
                                'cwe_id': 'CWE-89',
                                'confidence': 0.8
                            })

            except Exception:
                continue

        return findings

    async def _test_xss_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Test for Cross-Site Scripting vulnerabilities"""
        findings = []

        # XSS payloads
        payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "'\"><script>alert('XSS')</script>",
            "<svg onload=alert('XSS')>"
        ]

        for payload in payloads:
            try:
                test_data = {
                    "jsonrpc": "2.0",
                    "method": "chat",
                    "params": {"message": payload},
                    "id": "xss_test"
                }

                async with aiohttp.ClientSession() as session:
                    async with session.post(target, json=test_data, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        response_text = await response.text()

                        # Check for reflected payload
                        if payload in response_text:
                            findings.append({
                                'type': 'xss',
                                'severity': 'medium',
                                'description': 'Potential Cross-Site Scripting vulnerability detected',
                                'payload': payload,
                                'owasp_category': 'A03:2021 - Injection',
                                'cwe_id': 'CWE-79',
                                'confidence': 0.7
                            })

            except Exception:
                continue

        return findings

    async def _test_csrf_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Test for CSRF vulnerabilities"""
        findings = []

        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(target, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    headers = dict(response.headers)

                    # Check for CSRF protection headers
                    csrf_headers = ['X-CSRF-Token', 'X-XSRF-Token', 'X-CSRFToken']
                    has_csrf_protection = any(header in headers for header in csrf_headers)

                    if not has_csrf_protection:
                        findings.append({
                            'type': 'csrf',
                            'severity': 'medium',
                            'description': 'No CSRF protection headers detected',
                            'owasp_category': 'A01:2021 - Broken Access Control',
                            'cwe_id': 'CWE-352',
                            'confidence': 0.6
                        })

        except Exception:
            pass

        return findings

    async def _test_directory_traversal(self, target: str) -> List[Dict[str, Any]]:
        """Test for directory traversal vulnerabilities"""
        findings = []

        # Directory traversal payloads
        payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "....//....//....//etc/passwd"
        ]

        for payload in payloads:
            try:
                test_data = {
                    "jsonrpc": "2.0",
                    "method": "file_read",
                    "params": {"path": payload},
                    "id": "traversal_test"
                }

                async with aiohttp.ClientSession() as session:
                    async with session.post(target, json=test_data, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        response_text = await response.text()

                        # Check for system file contents
                        if 'root:' in response_text or 'localhost' in response_text:
                            findings.append({
                                'type': 'directory_traversal',
                                'severity': 'high',
                                'description': 'Directory traversal vulnerability detected',
                                'payload': payload,
                                'owasp_category': 'A01:2021 - Broken Access Control',
                                'cwe_id': 'CWE-22',
                                'confidence': 0.9
                            })

            except Exception:
                continue

        return findings

    async def _test_authentication_bypass(self, target: str) -> List[Dict[str, Any]]:
        """Test for authentication bypass vulnerabilities"""
        findings = []

        # Authentication bypass attempts
        bypass_attempts = [
            {"username": "admin", "password": "admin"},
            {"username": "administrator", "password": "password"},
            {"username": "' OR '1'='1", "password": "anything"},
            {"username": "admin", "password": "' OR '1'='1"}
        ]

        for attempt in bypass_attempts:
            try:
                test_data = {
                    "jsonrpc": "2.0",
                    "method": "authenticate",
                    "params": attempt,
                    "id": "auth_test"
                }

                async with aiohttp.ClientSession() as session:
                    async with session.post(target, json=test_data, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        if response.status == 200:
                            response_text = await response.text()
                            if 'success' in response_text.lower() or 'authenticated' in response_text.lower():
                                findings.append({
                                    'type': 'authentication_bypass',
                                    'severity': 'critical',
                                    'description': 'Authentication bypass vulnerability detected',
                                    'credentials': attempt,
                                    'owasp_category': 'A07:2021 - Identification and Authentication Failures',
                                    'cwe_id': 'CWE-287',
                                    'confidence': 0.8
                                })

            except Exception:
                continue

        return findings

    async def _test_ssl_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Test for SSL/TLS vulnerabilities"""
        findings = []

        # This would integrate with SSL analysis from infrastructure agent
        # For now, basic check
        parsed_url = urlparse(target)
        if parsed_url.scheme != 'https':
            findings.append({
                'type': 'ssl_vulnerability',
                'severity': 'medium',
                'description': 'HTTPS not enforced',
                'owasp_category': 'A02:2021 - Cryptographic Failures',
                'cwe_id': 'CWE-319',
                'confidence': 1.0
            })

        return findings

    async def _test_security_headers(self, target: str) -> List[Dict[str, Any]]:
        """Test for missing security headers"""
        findings = []

        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(target, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    headers = dict(response.headers)

                    required_headers = {
                        'Strict-Transport-Security': 'HSTS header missing',
                        'Content-Security-Policy': 'CSP header missing',
                        'X-Frame-Options': 'X-Frame-Options header missing',
                        'X-Content-Type-Options': 'X-Content-Type-Options header missing'
                    }

                    for header, description in required_headers.items():
                        if header not in headers:
                            findings.append({
                                'type': 'missing_security_header',
                                'severity': 'low',
                                'description': description,
                                'header': header,
                                'owasp_category': 'A05:2021 - Security Misconfiguration',
                                'cwe_id': 'CWE-16',
                                'confidence': 1.0
                            })

        except Exception:
            pass

        return findings

    async def _test_information_disclosure(self, target: str) -> List[Dict[str, Any]]:
        """Test for information disclosure vulnerabilities"""
        findings = []

        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(target, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    headers = dict(response.headers)

                    # Check for sensitive headers
                    sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
                    for header in sensitive_headers:
                        if header in headers:
                            findings.append({
                                'type': 'information_disclosure',
                                'severity': 'low',
                                'description': f'Server information disclosed in {header} header',
                                'header': header,
                                'value': headers[header],
                                'owasp_category': 'A05:2021 - Security Misconfiguration',
                                'cwe_id': 'CWE-200',
                                'confidence': 0.8
                            })

        except Exception:
            pass

        return findings

    async def _test_api_enumeration(self, target: str) -> List[Dict[str, Any]]:
        """Test for API enumeration vulnerabilities"""
        findings = []

        # Common API endpoints
        api_endpoints = ['/api/v1/', '/api/docs', '/swagger', '/openapi.json', '/graphql']

        for endpoint in api_endpoints:
            try:
                test_url = target.rstrip('/') + endpoint
                async with aiohttp.ClientSession() as session:
                    async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        if response.status == 200:
                            findings.append({
                                'type': 'api_enumeration',
                                'severity': 'low',
                                'description': f'API endpoint discovered: {endpoint}',
                                'endpoint': endpoint,
                                'owasp_category': 'A05:2021 - Security Misconfiguration',
                                'cwe_id': 'CWE-200',
                                'confidence': 0.9
                            })

            except Exception:
                continue

        return findings

    async def _test_rate_limiting(self, target: str) -> List[Dict[str, Any]]:
        """Test for rate limiting vulnerabilities"""
        findings = []

        try:
            # Send multiple rapid requests
            async with aiohttp.ClientSession() as session:
                tasks = []
                for i in range(10):
                    task = session.get(target, timeout=aiohttp.ClientTimeout(total=5))
                    tasks.append(task)

                responses = await asyncio.gather(*tasks, return_exceptions=True)

                # Check if all requests succeeded (indicating no rate limiting)
                successful_requests = sum(1 for r in responses if hasattr(r, 'status') and r.status == 200)

                if successful_requests >= 8:  # Most requests succeeded
                    findings.append({
                        'type': 'rate_limiting',
                        'severity': 'medium',
                        'description': 'No rate limiting detected',
                        'owasp_category': 'A04:2021 - Insecure Design',
                        'cwe_id': 'CWE-770',
                        'confidence': 0.7
                    })

        except Exception:
            pass

        return findings

    async def _test_api_authentication(self, target: str) -> List[Dict[str, Any]]:
        """Test for API authentication issues"""
        findings = []

        try:
            # Test without authentication
            async with aiohttp.ClientSession() as session:
                async with session.get(target, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    if response.status == 200:
                        response_text = await response.text()
                        if 'data' in response_text or 'result' in response_text:
                            findings.append({
                                'type': 'api_authentication',
                                'severity': 'high',
                                'description': 'API accessible without authentication',
                                'owasp_category': 'A01:2021 - Broken Access Control',
                                'cwe_id': 'CWE-306',
                                'confidence': 0.8
                            })

        except Exception:
            pass

        return findings

    async def _test_default_credentials(self, target: str) -> List[Dict[str, Any]]:
        """Test for default credentials"""
        findings = []

        default_creds = [
            ('admin', 'admin'),
            ('administrator', 'password'),
            ('root', 'root'),
            ('user', 'user')
        ]

        for username, password in default_creds:
            try:
                test_data = {
                    "jsonrpc": "2.0",
                    "method": "login",
                    "params": {"username": username, "password": password},
                    "id": "default_cred_test"
                }

                async with aiohttp.ClientSession() as session:
                    async with session.post(target, json=test_data, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        if response.status == 200:
                            response_text = await response.text()
                            if 'success' in response_text.lower():
                                findings.append({
                                    'type': 'default_credentials',
                                    'severity': 'critical',
                                    'description': f'Default credentials found: {username}:{password}',
                                    'credentials': {'username': username, 'password': password},
                                    'owasp_category': 'A07:2021 - Identification and Authentication Failures',
                                    'cwe_id': 'CWE-521',
                                    'confidence': 0.9
                                })

            except Exception:
                continue

        return findings

    async def _test_backup_files(self, target: str) -> List[Dict[str, Any]]:
        """Test for accessible backup files"""
        findings = []

        backup_files = [
            '/backup.sql', '/backup.zip', '/backup.tar.gz',
            '/db_backup.sql', '/site_backup.zip', '/.git/',
            '/config.bak', '/settings.old'
        ]

        for backup_file in backup_files:
            try:
                test_url = target.rstrip('/') + backup_file
                async with aiohttp.ClientSession() as session:
                    async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        if response.status == 200:
                            findings.append({
                                'type': 'backup_file_exposure',
                                'severity': 'medium',
                                'description': f'Backup file accessible: {backup_file}',
                                'file': backup_file,
                                'owasp_category': 'A05:2021 - Security Misconfiguration',
                                'cwe_id': 'CWE-200',
                                'confidence': 0.9
                            })

            except Exception:
                continue

        return findings

    async def _test_configuration_files(self, target: str) -> List[Dict[str, Any]]:
        """Test for accessible configuration files"""
        findings = []

        config_files = [
            '/.env', '/config.json', '/settings.json',
            '/web.config', '/.htaccess', '/phpinfo.php'
        ]

        for config_file in config_files:
            try:
                test_url = target.rstrip('/') + config_file
                async with aiohttp.ClientSession() as session:
                    async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        if response.status == 200:
                            findings.append({
                                'type': 'configuration_file_exposure',
                                'severity': 'high',
                                'description': f'Configuration file accessible: {config_file}',
                                'file': config_file,
                                'owasp_category': 'A05:2021 - Security Misconfiguration',
                                'cwe_id': 'CWE-200',
                                'confidence': 0.9
                            })

            except Exception:
                continue

        return findings

    async def _perform_risk_assessment(self, findings: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Perform comprehensive risk assessment"""
        risk_scores = {'critical': 10, 'high': 7, 'medium': 4, 'low': 1}

        total_risk = sum(risk_scores.get(f.get('severity', 'low'), 1) for f in findings)

        return {
            'total_risk_score': total_risk,
            'risk_level': 'critical' if total_risk > 50 else 'high' if total_risk > 25 else 'medium' if total_risk > 10 else 'low',
            'vulnerability_distribution': {
                severity: len([f for f in findings if f.get('severity') == severity])
                for severity in ['critical', 'high', 'medium', 'low']
            },
            'top_risks': sorted(findings, key=lambda x: risk_scores.get(x.get('severity', 'low'), 1), reverse=True)[:5]
        }

    async def _map_to_owasp_categories(self, findings: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Map findings to OWASP Top 10 categories"""
        owasp_mapping = {}

        for finding in findings:
            category = finding.get('owasp_category', 'Other')
            if category not in owasp_mapping:
                owasp_mapping[category] = []
            owasp_mapping[category].append(finding['type'])

        return {
            'categories': owasp_mapping,
            'coverage': len(owasp_mapping),
            'most_common': max(owasp_mapping.items(), key=lambda x: len(x[1]))[0] if owasp_mapping else None
        }

    async def _analyze_exploitability(self, findings: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze exploitability of findings"""
        exploitable_findings = []

        for finding in findings:
            if finding.get('severity') in ['critical', 'high']:
                exploitability_score = self._calculate_exploitability_score(finding)
                if exploitability_score > 0.6:
                    exploitable_findings.append({
                        'finding': finding,
                        'exploitability_score': exploitability_score
                    })

        return {
            'exploitable_count': len(exploitable_findings),
            'exploitable_findings': exploitable_findings,
            'immediate_threats': [f for f in exploitable_findings if f['exploitability_score'] > 0.8]
        }

    async def _generate_remediation_guidance(self, findings: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate remediation guidance for findings"""
        remediation_map = {
            'sql_injection': 'Use parameterized queries and input validation',
            'xss': 'Implement output encoding and Content Security Policy',
            'csrf': 'Implement CSRF tokens and SameSite cookies',
            'directory_traversal': 'Validate and sanitize file paths',
            'authentication_bypass': 'Implement strong authentication mechanisms',
            'ssl_vulnerability': 'Upgrade to TLS 1.2+ and strong cipher suites',
            'missing_security_header': 'Implement recommended security headers',
            'information_disclosure': 'Remove or obfuscate sensitive information',
            'default_credentials': 'Change default credentials immediately',
            'backup_file_exposure': 'Remove or protect backup files',
            'configuration_file_exposure': 'Protect configuration files from public access'
        }

        guidance = {}
        priority_order = []

        for finding in findings:
            finding_type = finding.get('type', 'unknown')
            if finding_type in remediation_map:
                guidance[finding_type] = {
                    'remediation': remediation_map[finding_type],
                    'priority': self._get_remediation_priority(finding),
                    'effort': self._estimate_remediation_effort(finding)
                }

        # Sort by priority
        priority_order = sorted(guidance.items(), key=lambda x: x[1]['priority'], reverse=True)

        return {
            'guidance': guidance,
            'priority_order': priority_order,
            'immediate_actions': [item for item in priority_order if item[1]['priority'] >= 8]
        }

    def _calculate_exploitability_score(self, finding: Dict[str, Any]) -> float:
        """Calculate exploitability score for a finding"""
        base_score = 0.5

        # Increase score based on severity
        severity_boost = {
            'critical': 0.4,
            'high': 0.3,
            'medium': 0.2,
            'low': 0.1
        }
        base_score += severity_boost.get(finding.get('severity', 'low'), 0.1)

        # Increase score based on type
        high_exploitability_types = [
            'sql_injection', 'authentication_bypass', 'default_credentials',
            'directory_traversal', 'configuration_file_exposure'
        ]

        if finding.get('type') in high_exploitability_types:
            base_score += 0.2

        return min(base_score, 1.0)

    def _get_remediation_priority(self, finding: Dict[str, Any]) -> int:
        """Get remediation priority (1-10 scale)"""
        severity_priority = {
            'critical': 10,
            'high': 8,
            'medium': 5,
            'low': 2
        }
        return severity_priority.get(finding.get('severity', 'low'), 2)

    def _estimate_remediation_effort(self, finding: Dict[str, Any]) -> str:
        """Estimate remediation effort"""
        high_effort_types = ['sql_injection', 'xss', 'authentication_bypass']
        medium_effort_types = ['csrf', 'missing_security_header', 'ssl_vulnerability']

        if finding.get('type') in high_effort_types:
            return 'high'
        elif finding.get('type') in medium_effort_types:
            return 'medium'
        else:
            return 'low'

    def _create_vulnerability_summary(self, findings: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Create vulnerability summary"""
        return {
            'total_vulnerabilities': len(findings),
            'by_severity': {
                severity: len([f for f in findings if f.get('severity') == severity])
                for severity in ['critical', 'high', 'medium', 'low']
            },
            'by_type': {
                vuln_type: len([f for f in findings if f.get('type') == vuln_type])
                for vuln_type in set(f.get('type', 'unknown') for f in findings)
            },
            'top_vulnerabilities': [f.get('type') for f in findings[:5]]
        }

    def _calculate_confidence_score(self, vulnerability_results: Dict[str, Any], findings: List[Dict[str, Any]]) -> float:
        """Calculate confidence score for vulnerability assessment"""
        # Base confidence from assessment coverage
        methods_used = len(vulnerability_results.get('assessment_methods', []))
        base_confidence = min(methods_used / 5, 1.0)  # 5 assessment categories

        # Boost confidence based on findings quality
        if findings:
            avg_confidence = sum(f.get('confidence', 0.5) for f in findings) / len(findings)
            base_confidence = (base_confidence + avg_confidence) / 2

        return round(base_confidence, 2)

    def _update_learning_data(self, vulnerability_results: Dict[str, Any], findings: List[Dict[str, Any]]):
        """Update learning data for future improvements"""
        # Track pattern effectiveness
        for finding in findings:
            pattern_type = finding.get('type', 'unknown')
            if pattern_type not in self.pattern_effectiveness:
                self.pattern_effectiveness[pattern_type] = {'detected': 0, 'false_positives': 0}

            self.pattern_effectiveness[pattern_type]['detected'] += 1

        # Update vulnerability trends
        current_date = datetime.now().strftime('%Y-%m-%d')
        if current_date not in self.vulnerability_trends:
            self.vulnerability_trends[current_date] = {}

        for finding in findings:
            vuln_type = finding.get('type', 'unknown')
            if vuln_type not in self.vulnerability_trends[current_date]:
                self.vulnerability_trends[current_date][vuln_type] = 0
            self.vulnerability_trends[current_date][vuln_type] += 1

    def _initialize_vulnerability_patterns(self) -> Dict[str, List[str]]:
        """Initialize vulnerability detection patterns"""
        return {
            'sql_injection': [
                'sql syntax error',
                'mysql_fetch',
                'ora-01756',
                'microsoft ole db',
                'postgresql error'
            ],
            'xss': [
                '<script',
                'javascript:',
                'onerror=',
                'onload=',
                'onclick='
            ],
            'directory_traversal': [
                '../',
                '..\\',
                '/etc/passwd',
                'windows/system32'
            ]
        }

    def _initialize_owasp_categories(self) -> Dict[str, str]:
        """Initialize OWASP Top 10 2021 categories"""
        return {
            'A01:2021': 'Broken Access Control',
            'A02:2021': 'Cryptographic Failures',
            'A03:2021': 'Injection',
            'A04:2021': 'Insecure Design',
            'A05:2021': 'Security Misconfiguration',
            'A06:2021': 'Vulnerable and Outdated Components',
            'A07:2021': 'Identification and Authentication Failures',
            'A08:2021': 'Software and Data Integrity Failures',
            'A09:2021': 'Security Logging and Monitoring Failures',
            'A10:2021': 'Server-Side Request Forgery (SSRF)'
        }

    def _initialize_cve_patterns(self) -> Dict[str, Dict[str, Any]]:
        """Initialize CVE pattern matching"""
        return {
            'high_priority_cves': {
                'CVE-2021-44228': {'description': 'Log4j RCE', 'severity': 'critical'},
                'CVE-2021-34527': {'description': 'PrintNightmare', 'severity': 'critical'},
                'CVE-2021-26855': {'description': 'Exchange Server SSRF', 'severity': 'critical'}
            }
        }

    def _initialize_risk_matrix(self) -> Dict[str, Dict[str, str]]:
        """Initialize risk assessment matrix"""
        return {
            'impact': {
                'high': 'Significant business impact',
                'medium': 'Moderate business impact',
                'low': 'Minimal business impact'
            },
            'likelihood': {
                'high': 'Very likely to be exploited',
                'medium': 'Possible to exploit',
                'low': 'Unlikely to be exploited'
            }
        }

    def _initialize_severity_scoring(self) -> Dict[str, int]:
        """Initialize severity scoring system"""
        return {
            'critical': 10,
            'high': 7,
            'medium': 4,
            'low': 1,
            'info': 0
        }